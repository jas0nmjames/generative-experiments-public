<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Arrival Logogram Panel — v3 (deterministic, round‑trip, split UI)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --bg0:#0b1013; --bg1:#141c22; --hud:#c8d3d8; --hud-dim:#8d9aa1; --accent:#91b6c3;
    --panel: rgba(20,28,34,.55); --glass-line: rgba(200,220,230,.06);
    --parx: 0; --pary: 0; /* parallax set by JS */
  }
  html,body{height:100%}
  body{
    margin:0; color:var(--hud); font:14px/1.5 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;
    background: radial-gradient(1200px 800px at 60% 30%, #1a2329 0%, var(--bg1) 40%, var(--bg0) 100%);
    overflow:hidden;
  }

  /* Fog (with parallax) */
  .fogWrap{position:fixed; inset:-10%; pointer-events:none; transform:translate3d(calc(var(--parx)*2%), calc(var(--pary)*1%), 0);}
  .fog, .fog::before, .fog::after{
    position:absolute; inset:-20%;
    background:
      radial-gradient(60% 50% at 40% 40%, rgba(255,255,255,.045), transparent 60%),
      radial-gradient(35% 30% at 70% 60%, rgba(255,255,255,.035), transparent 70%),
      radial-gradient(50% 40% at 30% 70%, rgba(255,255,255,.03), transparent 70%);
    filter: blur(10px) saturate(.8);
    animation: drift 70s linear infinite;
    opacity:.75; mix-blend-mode:screen;
  }
  .fog::before{content:""; inset:-20%;
    background:
      radial-gradient(55% 45% at 60% 30%, rgba(255,255,255,.04), transparent 60%),
      radial-gradient(45% 35% at 20% 70%, rgba(255,255,255,.03), transparent 70%);
    animation-duration:95s; animation-direction:reverse; opacity:.55;
  }
  .fog::after{content:""; inset:-20%;
    background:
      radial-gradient(40% 35% at 80% 50%, rgba(255,255,255,.03), transparent 60%),
      radial-gradient(30% 25% at 30% 30%, rgba(255,255,255,.025), transparent 70%);
    animation-duration:120s; opacity:.45;
  }
  @keyframes drift{0%{transform:translate3d(-5%,0,0) scale(1.05)}50%{transform:translate3d(6%,1%,0) scale(1.08)}100%{transform:translate3d(-5%,0,0) scale(1.05)}}

  .stage{
    position:absolute; inset:0; display:grid;
    grid-template-columns: 1fr min(1280px, 78vw) minmax(360px, 440px) 1fr;
    grid-template-rows: 8vh auto 8vh; place-items:center;
  }
  .viewport-wrap{ grid-column:2; grid-row:2; width:100% }
  .viewport{
    position: relative; width:100%; aspect-ratio: 21/9;
    border:16px solid #0e1418; border-radius:14px;
    box-shadow: inset 0 0 0 1px #151c21, inset 0 0 120px rgba(0,0,0,.6), 0 20px 60px rgba(0,0,0,.45);
    background:
      linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,0) 14%),
      radial-gradient(120% 85% at 50% 50%, rgba(121,143,153,.08), rgba(100,120,128,.05) 44%, rgba(40,50,56,.06) 60%, rgba(12,16,20,.28) 100%),
      linear-gradient(to bottom, rgba(200,210,215,.06), rgba(200,210,215,.02) 40%, rgba(200,210,215,.03) 60%, rgba(200,210,215,.04) 100%);
    overflow:hidden; cursor:crosshair;
  }
  .viewport::before{
    content:""; position:absolute; inset:-8%;
    background:
      radial-gradient(52% 40% at 48% 42%, rgba(183,195,201,.22), transparent 60%),
      radial-gradient(30% 25% at 68% 35%, rgba(183,195,201,.15), transparent 70%),
      radial-gradient(35% 30% at 38% 70%, rgba(183,195,201,.12), transparent 70%);
    filter: blur(14px); opacity:.55; animation: panelfog 42s ease-in-out infinite alternate; mix-blend-mode:screen;
    transform: translate3d(calc(var(--parx)*1%), calc(var(--pary)*1%), 0);
  }
  @keyframes panelfog{from{transform: translate3d(-1%,0,0) scale(1.02)}to{transform: translate3d(1.5%,1%,0) scale(1.06)}}
  .viewport::after{
    content:""; position:absolute; inset:0;
    background:
      repeating-linear-gradient(to bottom, var(--glass-line) 0, var(--glass-line) 1px, transparent 3px, transparent 7px),
      radial-gradient(120% 100% at 50% 110%, rgba(0,0,0,.45), transparent 40%);
    opacity:.5; pointer-events:none;
  }

  .horizon{ position:absolute; left:0; right:0; bottom: calc(12vh); height:1px;
    background: linear-gradient(to right, transparent, rgba(255,255,255,.06), transparent);
    opacity:.35; filter: blur(.3px);
  }

  .ink-surface{ position:absolute; inset:0; display:grid; place-items:center; }
  #svg{ width:min(70vmin, 76%); height:auto; transform: translate3d(calc(var(--parx)*0.6%), calc(var(--pary)*0.6%), 0); }
  .reflection{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none; opacity:.11; filter: blur(1.5px);
    transform: translate3d(calc(var(--parx)*-0.8%), calc(var(--pary)*-0.8%), 0) translateY(2px); }
  #reflSVG{ transform: scaleY(-1) translateY(-6px); opacity:.6 }
  #smudge{ position:absolute; inset:0; pointer-events:none; mix-blend-mode: screen; opacity:.55; }

  /* HUD split */
  .hud{ grid-column:3; grid-row:2; width:100%; display:grid; gap:12px; }
  .panel{
    backdrop-filter: blur(6px);
    background: var(--panel);
    border: 1px solid rgba(255,255,255,.06);
    border-radius: 12px;
    box-shadow: 0 10px 50px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
    padding:14px; color:var(--hud);
  }
  .panel h2{ margin:0 0 10px; font:600 12px/1.2 ui-sans-serif; letter-spacing:.18em; text-transform:uppercase; color:#d7e1e6 }
  .sub{ color:var(--hud-dim); font-size:12px; margin-bottom:10px }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:10px }
  .panel input[type=text]{ flex:1 1 auto; min-width:260px; padding:.55rem .7rem; color:#e9f0f3;
    background:linear-gradient(to bottom, rgba(255,255,255,.08), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.18); border-radius:10px; outline:none; }
  .panel label{ color:var(--hud-dim); font-size:12px; display:flex; gap:6px; align-items:center }
  .panel input[type=number], .panel input[type=range]{ accent-color: var(--accent); }
  .panel button{ padding:.55rem .85rem; border-radius:10px; border:1px solid rgba(255,255,255,.18);
    background:linear-gradient(to bottom, rgba(145,182,195,.28), rgba(145,182,195,.18)); color:#0b1013; font-weight:600; letter-spacing:.02em; cursor:pointer; }
  .panel button:hover{ filter: brightness(1.08) }
  .pill { padding:.25rem .55rem; border-radius:999px; font-size:12px; background:rgba(200,230,240,.12); border:1px solid rgba(255,255,255,.12) }
  .meter{ width:160px; height:10px; background:rgba(255,255,255,.08); border-radius:6px; overflow:hidden; box-shadow: inset 0 0 0 1px rgba(255,255,255,.08) }
  .meter>span{ display:block; height:100%; width:0%; transition:width .2s ease }
  .ok{ background:#68cf9a } .warn{ background:#f0b44a } .bad{ background:#f06464 }
  #warning{ color:#f17171; font-size:12px; display:none }

  /* Decoder area */
  .dropzone{ border:1px dashed rgba(200,230,240,.35); border-radius:10px; padding:14px; text-align:center; color:#cfe1e8; background:rgba(255,255,255,.03) }
  .dropzone.drag{ background:rgba(145,182,195,.1); border-color:#91b6c3 }
  pre.payload{ white-space:pre-wrap; color:#cfe1e8; background:rgba(255,255,255,.04); padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,.08); max-height:32vh; overflow:auto }

  @media (max-width:1100px){
    .stage{ grid-template-columns: 1fr min(96vw, 1000px) 1fr; grid-template-rows: 6vh auto auto 6vh; }
    .viewport-wrap{ grid-column:2; grid-row:2 }
    .hud{ grid-column:2; grid-row:3; width:min(96vw, 1000px) }
    #svg{ width:min(80vmin, 86%) }
  }
</style>
</head>
<body>

<div class="fogWrap"><div class="fog"></div></div>

<div class="stage">
  <div class="viewport-wrap">
    <div class="viewport" id="viewport">
      <div class="ink-surface">
        <!-- Main SVG -->
        <svg id="svg" viewBox="-520 -520 1040 1040" role="img" aria-label="Arrival-style logogram">
          <defs>
            <!-- Grit filter -->
            <filter id="gritty" x="-35%" y="-35%" width="170%" height="170%" color-interpolation-filters="sRGB">
              <feTurbulence type="turbulence" baseFrequency="0.006" numOctaves="2" seed="7" result="macro"/>
              <feDisplacementMap in="SourceGraphic" in2="macro" scale="6" xChannelSelector="R" yChannelSelector="G" result="warp1"/>
              <feTurbulence type="turbulence" baseFrequency="0.025" numOctaves="3" seed="11" result="micro"/>
              <feDisplacementMap in="warp1" in2="micro" scale="2.8" xChannelSelector="R" yChannelSelector="G" result="warp2"/>
              <feGaussianBlur in="warp2" stdDeviation="0.6" result="soft"/>
              <feComponentTransfer in="soft" result="ink">
                <feFuncA type="table" tableValues="0 0 0.15 0.55 0.85 1 1"/>
              </feComponentTransfer>
              <feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="2" seed="3" result="grain"/>
              <feColorMatrix in="grain" type="saturate" values="0"/>
              <feBlend in="ink" in2="grain" mode="multiply"/>
            </filter>
            <!-- Erosion -->
            <filter id="erosion" x="-30%" y="-30%" width="160%" height="160%">
              <feTurbulence type="turbulence" baseFrequency="0.08" numOctaves="2" seed="19" result="noise"/>
              <feComponentTransfer in="noise">
                <feFuncR type="gamma" exponent="0.7"/>
                <feFuncG type="gamma" exponent="0.7"/>
                <feFuncB type="gamma" exponent="0.7"/>
              </feComponentTransfer>
              <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 2 -1" result="alphaCut"/>
            </filter>
            <!-- Texture -->
            <pattern id="inkTex" patternUnits="userSpaceOnUse" width="28" height="28">
              <rect width="28" height="28" fill="#000"/>
              <g opacity="0.08">
                <circle cx="6" cy="7" r="2" fill="#fff"/>
                <circle cx="20" cy="13" r="1.6" fill="#fff"/>
                <circle cx="10" cy="22" r="1.2" fill="#fff"/>
                <rect x="14" y="3" width="3" height="1" fill="#fff"/>
                <rect x="2" y="16" width="2" height="1" fill="#fff"/>
              </g>
            </pattern>
            <!-- Splatter gradient -->
            <radialGradient id="blob" r="1">
              <stop offset="0" stop-color="#000"/>
              <stop offset="1" stop-color="#000" stop-opacity="0"/>
            </radialGradient>
          </defs>

          <!-- Hidden DATA layer -->
          <g id="dataLayer" style="display:none"></g>

          <!-- Visible ART layer -->
          <g id="artHost" opacity="0.98">
            <mask id="speckleMask">
              <rect x="-520" y="-520" width="1040" height="1040" fill="#fff"/>
            </mask>
            <g id="ghostLayer"></g>
            <g id="mark" filter="url(#gritty)" mask="url(#speckleMask)"></g>
          </g>
        </svg>

        <!-- reflection + smudge -->
        <div class="reflection"><svg id="reflSVG" viewBox="-520 -520 1040 1040"></svg></div>
        <canvas id="smudge"></canvas>
      </div>
    </div>
  </div>

  <div class="horizon"></div>

  <!-- HUD: split panels -->
  <aside class="hud">

    <!-- GENERATE -->
    <section class="panel" id="genPanel">
      <h2>Generate</h2>
      <div class="sub">Type → Render → Download</div>
      <div class="row">
        <input id="txt" type="text" placeholder="enter message…" value="we are so bound by time" maxlength="32" />
        <button id="go">Render</button>
        <button id="dl">Download SVG</button>
        <button id="ambience">Ambience: Off</button>
      </div>
      <div class="row">
        <span id="chars" class="pill">0 / 32 chars</span>
        <span id="tokens" class="pill">0 / 6 tokens</span>
        <div class="meter" title="Legibility"><span id="meterBar" class="ok"></span></div>
        <span id="meterLabel" class="pill">density: 0%</span>
        <span id="warning">Too dense for one mark—shorten text or increase sectors.</span>
      </div>
      <div class="row">
        <label>Sectors <input id="sectors" type="number" min="48" max="128" value="64"></label>
        <label>Radius <input id="radius" type="number" min="180" max="420" value="300"></label>
        <label>Max stroke <input id="smax" type="number" min="6" max="90" value="36"></label>
        <label>Smoothing <input id="smooth" type="range" min="0" max="6" step="1" value="3"></label>
        <label>Seed offset <input id="seed" type="number" min="0" max="999999" value="0"></label>
      </div>
      <div class="row">
        <label>Inkiness <input id="inkiness" type="range" min="0" max="100" value="75"></label>
        <label>Grit <input id="grit" type="range" min="0" max="100" value="65"></label>
        <label>Bleed <input id="bleed" type="range" min="0" max="100" value="40"></label>
        <label>Splatters <input id="splats" type="range" min="0" max="100" value="60"></label>
      </div>
    </section>

    <!-- DECODE -->
    <section class="panel" id="decPanel">
      <h2>Decode</h2>
      <div class="sub">Upload a saved v3 SVG (or drop it here). We extract the original text + payload.</div>
      <div class="row">
        <label>Choose SVG <input id="fileInput" type="file" accept=".svg,image/svg+xml"></label>
        <button id="decodeCurrent">Decode current</button>
        <button id="copyDecoded">Copy JSON</button>
        <span id="decodeStatus" class="pill" style="background:rgba(200,230,240,.08)">Idle</span>
      </div>
      <div id="dropzone" class="dropzone">Drag & drop SVG here to decode</div>
      <details id="decodeDetails" open>
        <summary style="cursor:pointer;color:#d7e1e6;margin-top:8px">Decoded payload</summary>
        <pre id="decodeOut" class="payload">—</pre>
      </details>
    </section>

  </aside>
</div>

<script>
/* ====================== Core deterministic v3 + decoder ====================== */
const $=s=>document.querySelector(s), svgNS="http://www.w3.org/2000/svg";
const MAX_CHARS=32, MAX_TOKENS=6, D1=0.55, DMAX=1.10;
const STOP=new Set(['a','an','the','of','to','in','and','for','on','with','is','are','be','as','by','at','from','that','this','it','was','were']);
const SALT="heptapod_v3_2025_08";
function mulberry32(seed){let t=seed>>>0;return()=>{t|=0;t=t+0x6D2B79F5|0;let r=Math.imul(t^t>>>15,1|t);r^=r+Math.imul(r^r>>>7,61|r);return((r^r>>>14)>>>0)/4294967296;}}
function fnv1a(str){let h=0x811c9dc5;for(let i=0;i<str.length;i++){h^=str.charCodeAt(i);h=(h+((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)))>>>0;}return h>>>0;}
const clamp=(n,a,b)=>Math.max(a,Math.min(b,n)), lerp=(a,b,t)=>a+(b-a)*t;
const toksFiltered=s=>s.trim().split(/\s+/).filter(Boolean).filter(w=>!STOP.has(w.toLowerCase()));
function densityOf(W,th=0.04){let a=0;for(const v of W)if(v>th)a++;return a/W.length;}

function textToWeights(text,N,smoothK=3){
  const s=text.toLowerCase().normalize('NFKD').replace(/[\u0300-\u036f]/g,''), letters=s.replace(/[^a-z0-9 .,!?'-]/g,'');
  const W=new Float32Array(N); if(!letters.trim()) return W; const phase=fnv1a(letters)%N;
  for(let i=0;i<letters.length-1;i++){
    const a=letters[i], b=letters[i+1]; if(/\s/.test(a+b)) continue;
    const h=fnv1a(a+b), idx=(phase+(h%N))%N, amp=0.5+((h>>>8)&255)/255*0.5;
    W[idx]+=amp*(/[aeiou]/.test(b)?1.15:1.0);
  }
  for(const ch of letters){ if(/[.!?]/.test(ch)) zero(W,phase,4); if(/[,;:]/.test(ch)) zero(W,phase,2,0.65); }
  const mx=Math.max(1e-6,Math.max(...W)); for(let i=0;i<N;i++) W[i]/=mx;
  if(smoothK>0){
    const out=new Float32Array(N), kernel=[];
    for(let k=-smoothK;k<=smoothK;k++) kernel.push(Math.exp(-(k*k)/(2*(smoothK*0.6)*(smoothK*0.6))));
    const denom=kernel.reduce((a,b)=>a+b,0);
    for(let i=0;i<N;i++){let acc=0; for(let k=-smoothK;k<=smoothK;k++){const j=(i+k+N)%N; acc+=W[j]*kernel[k+smoothK];} out[i]=acc/denom; }
    return out;
  }
  return W;
  function zero(arr,c,r,f=0){ for(let k=-r;k<=r;k++){const j=(c+k+arr.length)%arr.length; arr[j]*=f; } }
}

function arcPath(cx,cy,r,a0,a1){
  const x0=cx+r*Math.cos(a0), y0=cy+r*Math.sin(a0), x1=cx+r*Math.cos(a1), y1=cy+r*Math.sin(a1);
  const large=(a1-a0)%(Math.PI*2)>Math.PI?1:0;
  return `M ${x0} ${y0} A ${r} ${r} 0 ${large} 1 ${x1} ${y1}`;
}
function noisyArcPath(rng,cx,cy,r,a0,a1,opts){
  const steps=opts.steps??8, jA=opts.jitterAng??0.015, jR=opts.jitterRad??6, pts=[];
  for(let i=0;i<=steps;i++){
    const t=i/steps, ang=lerp(a0,a1,t)+(rng()*2-1)*jA;
    const rad=r+(rng()*2-1)*jR+Math.sin((t+rng()*0.5)*Math.PI*2)*opts.radDrift;
    pts.push([cx+rad*Math.cos(ang), cy+rad*Math.sin(ang)]);
  }
  let d=`M ${pts[0][0]} ${pts[0][1]}`;
  for(let i=1;i<pts.length;i++){ const p0=pts[i-1], p1=pts[i]; const mx=(p0[0]+p1[0])/2, my=(p0[1]+p1[1])/2; d+=` Q ${p0[0]} ${p0[1]} ${mx} ${my}`; }
  d+=` T ${pts[pts.length-1][0]} ${pts[pts.length-1][1]}`; return d;
}

function drawNoisyRing({W,R,Smax,N,seedParams,layer}){
  const rng=mulberry32(seedParams.noiseSeed), start=-Math.PI/2, seg=(2*Math.PI)/N;
  const sectorJ=0.035*seedParams.inkiness, radDrift=3+10*seedParams.inkiness;
  const dryProb=0.12+0.25*seedParams.grit, dryScale=0.25+0.55*seedParams.grit;
  const passes0=2+Math.floor(2*seedParams.inkiness);

  for(let i=0;i<N;i++){
    const w=W[i]; if(w<=0.02) continue;
    const sw=lerp(6,Smax,Math.pow(w,0.85));
    const a0=start+i*seg+(rng()*2-1)*sectorJ, a1=start+(i+1)*seg+(rng()*2-1)*sectorJ;
    const passes=passes0+(w>0.6?1:0);

    for(let p=0;p<passes;p++){
      const rr=R+(rng()*2-1)*4*(1+w);
      const path=document.createElementNS(svgNS,"path");
      const d=noisyArcPath(rng,0,0,rr,a0,a1,{
        steps:8+Math.floor(6*seedParams.grit),
        jitterAng:0.006+0.018*seedParams.grit,
        jitterRad:2+6*seedParams.grit,
        radDrift:radDrift*(0.6+0.6*rng())
      });
      path.setAttribute("d",d);
      path.setAttribute("fill","none");
      path.setAttribute("stroke","url(#inkTex)");
      const amp=0.7+0.6*Math.sin((i+p)*0.7 + seedParams.noiseSeed*0.0002);
      const jit=0.85+rng()*0.35;
      path.setAttribute("stroke-width", sw*amp*jit);
      path.setAttribute("stroke-linecap","round");
      path.setAttribute("stroke-linejoin","round");

      if(rng()<dryProb){
        const gap=6+20*dryScale*rng(), dash=12+30*rng();
        path.setAttribute("stroke-dasharray", `${dash} ${gap}`);
        path.setAttribute("stroke-dashoffset", (rng()*gap).toFixed(2));
      }
      layer.appendChild(path);
    }

    if(w>0.4 && rng()<(0.35+0.35*seedParams.inkiness)){
      placeSplatterNear(layer,R,(rng()<0.5?a0:a1),w,rng,seedParams);
    }
  }
}

function placeSplatterNear(layer,R,angle,w,rng,seedParams){
  const count=1+Math.floor(rng()*2);
  for(let k=0;k<count;k++){
    const scale=0.6+0.8*seedParams.inkiness;
    const r=(5+w*22)*(0.5+rng()*1.4)*scale;
    const d=(rng()<0.5?-1:1)*(8+rng()*28);
    const x=(R+d)*Math.cos(angle)+(rng()*2-1)*9;
    const y=(R+d)*Math.sin(angle)+(rng()*2-1)*9;

    if(rng()<0.72){
      const c=document.createElementNS(svgNS,"circle");
      c.setAttribute("cx",x); c.setAttribute("cy",y); c.setAttribute("r",r);
      c.setAttribute("fill","url(#blob)"); c.setAttribute("opacity",0.82);
      layer.appendChild(c);
    } else {
      const e=document.createElementNS(svgNS,"ellipse");
      const elong=2.0+rng()*3.0;
      e.setAttribute("cx",x); e.setAttribute("cy",y);
      e.setAttribute("rx", r*elong); e.setAttribute("ry", r*0.42);
      e.setAttribute("fill","url(#blob)"); e.setAttribute("opacity",0.78);
      e.setAttribute("transform", `rotate(${(angle*180/Math.PI)+rng()*28})`);
      layer.appendChild(e);
    }
  }
}

function applyErosionMask(str){
  const mask=$("#speckleMask");
  [...mask.querySelectorAll(".noiseChunk")].forEach(n=>n.remove());
  if(str<=0) return;
  const g=document.createElementNS(svgNS,"g");
  g.setAttribute("class","noiseChunk"); g.setAttribute("filter","url(#erosion)"); g.setAttribute("opacity", str);
  const r=document.createElementNS(svgNS,"rect");
  r.setAttribute("x","-520"); r.setAttribute("y","-520"); r.setAttribute("width","1040"); r.setAttribute("height","1040"); r.setAttribute("fill","#888");
  g.appendChild(r); mask.appendChild(g);
}

function writeMetadata(payload){
  const old=$("#dataLayer #logogram-metadata"); if(old) old.remove();
  const meta={version:"v3",salt:SALT,text:payload.text,tokens:payload.toks,
    params:{N:payload.N,R:payload.R,Smax:payload.Smax,smoothing:payload.smoothK,inkiness:payload.inkiness,grit:payload.grit,bleed:payload.bleed,splatters:payload.splats,seed:payload.seed},
    weights:Array.from(payload.W)};
  const s=document.createElementNS(svgNS,"script");
  s.setAttribute("id","logogram-metadata"); s.setAttribute("type","application/json");
  s.textContent=JSON.stringify(meta); $("#dataLayer").appendChild(s);
}

function updateCounters(){
  const raw=$("#txt").value; $("#chars").textContent=`${raw.length} / ${MAX_CHARS} chars`;
  const t=toksFiltered(raw).slice(0,MAX_TOKENS); $("#tokens").textContent=`${t.length} / ${MAX_TOKENS} tokens`;
}
function updateMeter(d){
  const pct=Math.round(d*100), bar=$("#meterBar"), label=$("#meterLabel");
  bar.style.width=clamp(pct,0,110)+"%";
  bar.className= pct<=D1*100 ? "ok" : (pct<=DMAX*100 ? "warn" : "bad");
  label.textContent=`density: ${pct}%`;
}

function render(){
  const input=$("#txt"); if(input.value.length>MAX_CHARS) input.value=input.value.slice(0,MAX_CHARS);
  const toks=toksFiltered(input.value).slice(0,MAX_TOKENS), text=toks.join(' '); updateCounters();

  const N=+$("#sectors").value|0, R=+$("#radius").value, Smax=+$("#smax").value, smoothK=+$("#smooth").value|0, seedOffset=+$("#seed").value|0;
  const inkiness=+$("#inkiness").value/100, grit=+$("#grit").value/100, bleed=+$("#bleed").value/100, splats=+$("#splats").value/100;

  const baseSeed=fnv1a(`${SALT}|${text}|N=${N}|R=${R}|S=${Smax}|sm=${smoothK}|ink=${inkiness}|grit=${grit}|bleed=${bleed}|spl=${splats}`)^seedOffset;

  const W=textToWeights(text,N,smoothK), d=densityOf(W); updateMeter(d);

  $("#dataLayer").innerHTML=""; $("#mark").innerHTML=""; $("#ghostLayer").innerHTML="";
  applyErosionMask(0.2+grit*0.6);

  $("#warning").style.display="none";
  if(d>DMAX){ $("#warning").style.display="inline"; writeMetadata({text,toks,N,R,Smax,smoothK,inkiness,grit,bleed,splats,seed:baseSeed,W}); syncReflection(); return; }

  const seedParams={noiseSeed:baseSeed,inkiness,grit,bleed,splats};

  // DATA (clean)
  const start=-Math.PI/2, seg=(2*Math.PI)/N;
  for(let i=0;i<N;i++){
    const w=W[i]; if(w<=0.02) continue;
    const p=document.createElementNS(svgNS,"path");
    p.setAttribute("d", arcPath(0,0,R, start+i*seg, start+(i+1)*seg));
    p.setAttribute("fill","none"); p.setAttribute("stroke","#000"); p.setAttribute("stroke-width",(w*Smax).toFixed(3));
    p.setAttribute("data-sector", String(i)); p.setAttribute("data-weight", w.toFixed(5));
    $("#dataLayer").appendChild(p);
  }

  // ART (noisy)
  if(d>D1){
    const idx=[...W.keys()].sort((a,b)=>W[b]-W[a]); const half=Math.floor(N/2); const outer=new Set(idx.slice(0,half));
    drawNoisyRing({W,R, Smax:Smax*(0.95+inkiness*0.4), N, seedParams, layer:$("#mark")});
    const Win=W.slice(); for(let i=0;i<N;i++) if(outer.has(i)) Win[i]=0;
    drawNoisyRing({W:Win,R:R-26, Smax:Smax*0.72, N, seedParams, layer:$("#mark")});
  } else {
    drawNoisyRing({W,R, Smax:Smax*(0.9+inkiness*0.5), N, seedParams, layer:$("#mark")});
  }

  // Ghost print
  if(inkiness>0.05 || bleed>0.02){
    const clone=$("#mark").cloneNode(true), wrap=document.createElementNS(svgNS,"g");
    const fId="ghost"+baseSeed, f=document.createElementNS(svgNS,"filter"); f.setAttribute("id",fId);
    f.innerHTML=`<feGaussianBlur stdDeviation="${0.8+2.2*bleed}"/>`; $("#svg defs").appendChild(f);
    wrap.setAttribute("filter",`url(#${fId})`);
    const dx=1.2+1.8*inkiness, dy=1.2+1.8*inkiness;
    wrap.setAttribute("transform",`translate(${dx.toFixed(2)}, ${dy.toFixed(2)})`);
    wrap.setAttribute("opacity", 0.10+0.18*bleed);
    wrap.appendChild(clone); $("#ghostLayer").appendChild(wrap);
  }
  $("#artHost").setAttribute("opacity", 0.94 + inkiness*0.06);

  // Splatter field
  const rng=mulberry32(baseSeed^0xBEEFCAFE);
  const count=Math.round( (6+inkiness*10) * splats * (0.6+d) );
  for(let i=0;i<count;i++){
    const angle=rng()*Math.PI*2; const bias=(rng()<0.4) ? (Math.PI*1.75 + (rng()*0.6-0.3)) : angle;
    placeSplatterNear($("#mark"), R-10 + (rng()*2-1)*40, bias, 0.75, rng, seedParams);
  }

  writeMetadata({text,toks,N,R,Smax,smoothK,inkiness,grit,bleed,splats,seed:baseSeed,W});
  syncReflection();
}

function syncReflection(){
  const refl=$("#reflSVG");
  refl.innerHTML = $("#mark").outerHTML.replace('id="mark"',''); // mirror content only
}

/* --------------------------- Decoder helpers --------------------------- */
function decodeLogogram(svgSource){
  let svgDoc;
  if(typeof svgSource==="string"){
    svgDoc = new DOMParser().parseFromString(svgSource,"image/svg+xml").documentElement;
  } else if(svgSource && svgSource.tagName==="svg"){
    svgDoc = svgSource;
  } else { throw new Error("decodeLogogram: pass SVG string or <svg> element"); }

  // Try metadata block
  let meta=null; const metaEl=svgDoc.querySelector("#logogram-metadata");
  if(metaEl && metaEl.textContent){ try{ meta=JSON.parse(metaEl.textContent); }catch{} }

  // Fallback to data arcs
  if(!meta){
    const arcs=[...svgDoc.querySelectorAll("#dataLayer path[data-sector]")];
    if(!arcs.length) throw new Error("No metadata or data-layer arcs found in SVG.");
    const weights=new Array(arcs.length).fill(0);
    arcs.forEach(p=>{
      const s=parseInt(p.getAttribute("data-sector"),10);
      const w=parseFloat(p.getAttribute("data-weight"));
      weights[s]=w;
    });
    meta={version:"unknown", text:null, tokens:[], params:{N:arcs.length}, weights};
  }
  return { text:meta.text||null, tokens:meta.tokens||[], params:meta.params||{}, weights:meta.weights||[] };
}

function showDecoded(payload, sourceLabel){
  $("#decodeDetails").open = true;
  const json = JSON.stringify({
    text: payload.text,
    tokens: payload.tokens,
    params: payload.params,
    weightsPreview: payload.weights.slice(0,24)
  }, null, 2);
  $("#decodeOut").textContent = json;
  $("#decodeStatus").textContent = `Decoded ${sourceLabel} • sectors: ${payload.params?.N ?? "?"} • seed: ${payload.params?.seed ?? "?"}`;
}

/* ------------------------------ Ambience ------------------------------ */
let audioCtx=null, ambienceOn=false, nodes=null;
function makeAmbience(){
  if(audioCtx) return;
  audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  const master=audioCtx.createGain(); master.gain.value=0.0; master.connect(audioCtx.destination);

  // Low beating sines
  const o1=audioCtx.createOscillator(); o1.type="sine"; o1.frequency.value=52;
  const o2=audioCtx.createOscillator(); o2.type="sine"; o2.frequency.value=58.2;
  const g=audioCtx.createGain(); g.gain.value=0.02; o1.connect(g); o2.connect(g); g.connect(master); o1.start(); o2.start();

  // Brown noise air
  const noise=audioCtx.createBufferSource();
  const buf=audioCtx.createBuffer(1, audioCtx.sampleRate*2, audioCtx.sampleRate);
  const data=buf.getChannelData(0); let last=0; for(let i=0;i<data.length;i++){ const white=Math.random()*2-1; data[i]=(last+0.02*white)/1.02; last=data[i]; }
  noise.buffer=buf; noise.loop=true;
  const nGain=audioCtx.createGain(); nGain.gain.value=0.03;
  const lp=audioCtx.createBiquadFilter(); lp.type="lowpass"; lp.frequency.value=400; lp.Q.value=0.7;
  noise.connect(lp); lp.connect(nGain); nGain.connect(master); noise.start();

  const lfo=audioCtx.createOscillator(); lfo.type="sine"; lfo.frequency.value=0.08;
  const lfoG=audioCtx.createGain(); lfoG.gain.value=0.01; lfo.connect(lfoG); lfoG.connect(master.gain); lfo.start();

  nodes={master};
}
function toggleAmbience(){
  makeAmbience(); ambienceOn=!ambienceOn;
  $("#ambience").textContent="Ambience: " + (ambienceOn?"On":"Off");
  if(ambienceOn){
    audioCtx.resume();
    nodes.master.gain.cancelScheduledValues(audioCtx.currentTime);
    nodes.master.gain.linearRampToValueAtTime(0.12, audioCtx.currentTime+1.0);
  }else{
    nodes.master.gain.cancelScheduledValues(audioCtx.currentTime);
    nodes.master.gain.linearRampToValueAtTime(0.0, audioCtx.currentTime+0.6);
  }
}

/* --------------------- Parallax + glass smudge --------------------- */
const viewportEl=$("#viewport");
const smudge=$("#smudge"); const smCtx=smudge.getContext("2d");
function resizeSmudge(){
  const r=viewportEl.getBoundingClientRect();
  smudge.width=r.width*2; smudge.height=r.height*2;
  smudge.style.width=r.width+"px"; smudge.style.height=r.height+"px";
  smCtx.setTransform(1,0,0,1,0,0);
  smCtx.scale(2,2);
  smCtx.clearRect(0,0,r.width,r.height);
}
window.addEventListener("resize", resizeSmudge); resizeSmudge();

let lastRAF=0;
function smudgeLoop(ts){
  if(!lastRAF) lastRAF=ts;
  const r=viewportEl.getBoundingClientRect();
  // Fade existing smudges
  smCtx.globalCompositeOperation="destination-out";
  smCtx.globalAlpha=0.03; smCtx.fillRect(0,0,r.width,r.height);

  smCtx.globalCompositeOperation="lighter";
  smCtx.globalAlpha=0.09;
  requestAnimationFrame(smudgeLoop);
}
requestAnimationFrame(smudgeLoop);

function drawSmudge(x,y){
  const r=viewportEl.getBoundingClientRect();
  const cx=x-r.left, cy=y-r.top;
  const radius=Math.max(40, Math.min(r.width,r.height)*0.06);
  const g=smCtx.createRadialGradient(cx,cy,0,cx,cy,radius);
  g.addColorStop(0,"rgba(255,255,255,0.35)");
  g.addColorStop(0.4,"rgba(255,255,255,0.12)");
  g.addColorStop(1,"rgba(255,255,255,0)");
  smCtx.fillStyle=g; smCtx.beginPath(); smCtx.arc(cx,cy,radius,0,Math.PI*2); smCtx.fill();
}

viewportEl.addEventListener("pointermove",(e)=>{
  const r=viewportEl.getBoundingClientRect();
  const nx=(e.clientX-r.left)/r.width-0.5, ny=(e.clientY-r.top)/r.height-0.5;
  document.documentElement.style.setProperty("--parx",(nx*4).toFixed(3));
  document.documentElement.style.setProperty("--pary",(ny*3).toFixed(3));
  drawSmudge(e.clientX,e.clientY);
});
viewportEl.addEventListener("pointerleave",()=>{
  document.documentElement.style.setProperty("--parx","0");
  document.documentElement.style.setProperty("--pary","0");
});

/* --------------------------- UI wiring --------------------------- */
function downloadSVG(){
  const svg=$("#svg").cloneNode(true); svg.removeAttribute("width"); svg.removeAttribute("height");
  const blob=new Blob([new XMLSerializer().serializeToString(svg)],{type:"image/svg+xml;charset=utf-8"});
  const a=Object.assign(document.createElement("a"),{href:URL.createObjectURL(blob),download:"logogram-v3.svg"}); a.click(); URL.revokeObjectURL(a.href);
}

function decodeCurrent(){
  try{ const p=decodeLogogram($("#svg")); showDecoded(p,"current SVG"); }
  catch(e){ $("#decodeDetails").open=true; $("#decodeOut").textContent="Decode error: "+e.message; $("#decodeStatus").textContent="Error"; }
}

function handleFileDecode(file){
  const rd=new FileReader();
  rd.onload=()=>{
    try{
      const p=decodeLogogram(String(rd.result));
      showDecoded(p, `file: ${file.name}`);
    }catch(e){
      $("#decodeDetails").open=true; $("#decodeOut").textContent="Decode error: "+e.message; $("#decodeStatus").textContent="Error";
    }
  };
  rd.readAsText(file);
}

function wireDropzone(){
  const dz=$("#dropzone");
  ["dragenter","dragover"].forEach(ev=>dz.addEventListener(ev,(e)=>{e.preventDefault(); e.dataTransfer.dropEffect="copy"; dz.classList.add("drag");}));
  ["dragleave","dragend","drop"].forEach(ev=>dz.addEventListener(ev,()=>dz.classList.remove("drag")));
  dz.addEventListener("drop",(e)=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(f) handleFileDecode(f); });
}

function init(){
  $("#txt").addEventListener("input", ()=>{ const raw=$("#txt").value; $("#chars").textContent=`${raw.length} / ${MAX_CHARS} chars`; const t=toksFiltered(raw).slice(0,MAX_TOKENS); $("#tokens").textContent=`${t.length} / ${MAX_TOKENS} tokens`; });
  $("#go").addEventListener("click", render);
  $("#dl").addEventListener("click", downloadSVG);
  $("#decodeCurrent").addEventListener("click", decodeCurrent);
  $("#fileInput").addEventListener("change", e=>{ const f=e.target.files?.[0]; if(f) handleFileDecode(f); });
  $("#copyDecoded").addEventListener("click", async ()=>{
    try{ await navigator.clipboard.writeText($("#decodeOut").textContent||""); $("#decodeStatus").textContent="Copied"; setTimeout(()=>$("#decodeStatus").textContent="Idle",1200);}
    catch{ $("#decodeStatus").textContent="Copy failed"; setTimeout(()=>$("#decodeStatus").textContent="Idle",1200); }
  });
  $("#ambience").addEventListener("click", toggleAmbience);
  wireDropzone();

  // boot
  $("#chars").textContent=`${$("#txt").value.length} / ${MAX_CHARS} chars`;
  const t=toksFiltered($("#txt").value).slice(0,MAX_TOKENS); $("#tokens").textContent=`${t.length} / ${MAX_TOKENS} tokens`;
  render();
}
init();
</script>

</body>
</html>
